# -*- coding: utf-8 -*-
"""AgentAnalysis_multislot_ring.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PLGfyUqmJUc8ZbPRdrY53B2xuPlRPEp2
"""

import matplotlib.pyplot as plt
import numpy as  np
# import agents
import agents_nosensoryneuron as agents
import itertools
from itertools import product, permutations

best_fit = np.load('/Data/3sector-1/3s_Conceptual4_best_fit.npy')
mean_fit = np.load('/Data/3sector-1/3s_Conceptual4_mean_fit.npy')
genotype_best = np.load('/Data/3sector-1/3s_Conceptual4_individual_genotype.npy')

#plot fitness history
plt.figure()
plt.plot(best_fit)
plt.plot(mean_fit)
plt.xlabel('Generations')
plt.ylabel('Fitness')
plt.legend(['best fitness', 'avg. fitness'])
plt.show()

print(best_fit[7900])

# multiple-slot get trajectory
import importlib
import itertools
from itertools import product, permutations
importlib.reload(agents)
WeightRange = 15
TimeconstRange = 10
BiasRange = 10

InterSize = 5
slot_number =3  # set to 2 for 2-sector tasks
log_slots = int(np.ceil(np.log2(slot_number)))
sensor_num = log_slots + 2
environment_sample_percent = 1
random_seed =0
slots = slot_number

rng = np.random.default_rng(seed=random_seed)
# environment
log_slots = int(np.ceil(np.log2(slot_number)))
sensor_num = log_slots + 2
sender_sensor_num = sensor_num
receiver_sensor_num = sensor_num
environment_sample_size = int(np.ceil(np.math.factorial(slots)*environment_sample_percent))
#communication region: 0 ~ pi/2
sender_initial_position = np.pi/4                #initial angular position of the sender
receiver_initial_positions = np.pi/4 - np.array([-np.pi*3/32, np.pi*3/32]) # 2 initial positions of receiver
num_receiver_initial_positions = np.shape(receiver_initial_positions)[0]
slot_size = (3*np.pi/2)/slots

#time step
#communication phase: 30s; 
#courier phase: 60s, fitness function dependens on the time spent in the right area in the last 20s
phase_communication = 30                               
phase_courier = 60
stepsize = 0.1                              # Size of the numerical integration step
time_communication = np.arange(0.0,phase_communication,stepsize)     # Points in time
time_courier = np.arange(0.0,phase_courier,stepsize)     # Points in time

#set up agents
AgentS = agents.Agent(InterSize,sensor_num)
AgentR = agents.Agent(InterSize,sensor_num)
state0 = np.zeros(InterSize+2)         #initial state set to 0

#trials:
sensor_values = [-1, 1]
# below provides [(-1,), (1,)] when repeat=1
all_slot_names = list(product(sensor_values, repeat=log_slots))
# print(all_slot_names)
slot_names = rng.choice(all_slot_names, size=slots, replace=False)
# below provides [[[-1], [1]], [[1], [-1]]]
all_environments = list(permutations(slot_names))
sampled_environments = rng.choice(all_environments, size=environment_sample_size,replace=False)
print(sampled_environments) #[1],[-1] [-1],[1]

point_trials = np.zeros((environment_sample_size,num_receiver_initial_positions,slots))  #record the final point of each trial
trajectory = np.zeros([2,environment_sample_size,num_receiver_initial_positions,slots,900])         #record the trajectory of each trial; 0 for receiver, 1 for sender
receiver_sensor = np.zeros([sensor_num,environment_sample_size,num_receiver_initial_positions,slots,900])   #0 -left sensor, 1 - right sensor
receiver_interneuron_output = np.zeros([5,environment_sample_size,num_receiver_initial_positions,slots,900])
receiver_motor_output = np.zeros([2,environment_sample_size,num_receiver_initial_positions,slots,900])

for n,environment in enumerate(sampled_environments):
  for m,receiver_position_set in enumerate(receiver_initial_positions):
    for k,command in enumerate(sampled_environments[0,:,:]):
      
      #initialize agents
      AgentS.setWeights(np.reshape(WeightRange*(genotype_best[0:
                                                          sender_sensor_num*InterSize]*2-1),(sender_sensor_num,InterSize)),
                        np.reshape(WeightRange*(genotype_best[sender_sensor_num*InterSize:
                                                          sender_sensor_num*InterSize+InterSize**2]*2-1),
                                    (InterSize,InterSize)), 
                        np.reshape(WeightRange*(genotype_best[sender_sensor_num*InterSize+InterSize**2:
                                                          sender_sensor_num*InterSize+InterSize**2+InterSize*2]*2-1),
                                    (InterSize,2))) ## *WeightRange
      AgentR.setWeights(np.reshape(WeightRange*(genotype_best[sender_sensor_num*InterSize+InterSize**2+InterSize*2:
                                                          sender_sensor_num*InterSize+InterSize**2+InterSize*2+receiver_sensor_num*InterSize]*2-1),
                                    (receiver_sensor_num,InterSize)), 
                        np.reshape(WeightRange*(genotype_best[sender_sensor_num*InterSize+InterSize**2+InterSize*2+receiver_sensor_num*InterSize:
                                                          sender_sensor_num*InterSize+2*InterSize**2+InterSize*2+receiver_sensor_num*InterSize]*2-1),
                                    (InterSize,InterSize)), 
                        np.reshape(WeightRange*(genotype_best[sender_sensor_num*InterSize+2*InterSize**2+InterSize*2+receiver_sensor_num*InterSize:
                                                          sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize]*2-1),
                                    (InterSize,2)))
      AgentS.setBiases(BiasRange*(genotype_best[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize:
                                            sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize+2]*2-1))
      AgentR.setBiases(BiasRange*(genotype_best[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize+2:
                                            sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*2+4]*2-1))
      AgentS.setTimeConstants(genotype_best[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*2+4:
                                        sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*3+6]*TimeconstRange+1)
      AgentR.setTimeConstants(genotype_best[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*3+6:
                                        sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*4+8]*TimeconstRange+1)
      AgentS.initializeState(state0)
      AgentR.initializeState(state0)
      # print(state0)

      sender_input = np.zeros(sender_sensor_num)
      receiver_input = np.zeros(receiver_sensor_num)

      sender_position = sender_initial_position
      receiver_position = np.copy(receiver_position_set)

      point = 0   #the point receiver gets for evaluating fitness

      #communication phase
      for j,t in enumerate(time_communication):

          distance = sender_position - receiver_position
          #angular sensors
          if -2*np.pi < distance < -15*np.pi/8:
            sender_input[0] = (np.pi/8-(2*np.pi+sender_position - receiver_position))*8/np.pi
            sender_input[1] = 0
            receiver_input[0] = 0
            receiver_input[1] = (np.pi/8-(2*np.pi+sender_position - receiver_position))*8/np.pi
          elif 15*np.pi/8 < distance < 2*np.pi:
            sender_input[0] = 0
            sender_input[1] = (np.pi/8-(2*np.pi+receiver_position - sender_position))*8/np.pi
            receiver_input[0] = (np.pi/8-(2*np.pi+receiver_position - sender_position))*8/np.pi
            receiver_input[1] = 0
          elif distance > np.pi/8 or distance < -np.pi/8:       
            sender_input[0:2] = 0
            receiver_input[0:2] = 0
          elif 0 < distance < np.pi/8:
            sender_input[0] = (np.pi/8 - distance)*8/np.pi
            sender_input[1] = 0
            receiver_input[0] = 0
            receiver_input[1] = (np.pi/8 - distance)*8/np.pi
          
          else:
            sender_input[1] = (np.pi/8 + distance)*8/np.pi
            sender_input[0] = 0
            receiver_input[1] = 0
            receiver_input[0] = (np.pi/8 + distance)*8/np.pi

          #bearing sensors
          for i in range(len(command)):
            sender_input[i + 2] = command[i] #(-1,1) for the right slot
            receiver_input[i + 2] = 0 #communication region


          AgentS.step(stepsize,sender_input)
          AgentR.step(stepsize,receiver_input)
          sender_position += stepsize*(AgentS.Outputs[InterSize+1] - AgentS.Outputs[InterSize])
          receiver_position += stepsize*(AgentR.Outputs[InterSize+1] - AgentR.Outputs[InterSize])

           #close the circle -- in this phase, the whole ring is used for communication
          if receiver_position > 2*np.pi:
            receiver_position -= 2*np.pi
          elif receiver_position < 0:
            receiver_position += 2*np.pi

          if sender_position > 2*np.pi:
            sender_position -= 2*np.pi
          elif sender_position < 0:
            sender_position += 2*np.pi
        
        
          trajectory[0,n,m,k,j] = receiver_position
          trajectory[1,n,m,k,j] = sender_position
          receiver_sensor[:,n,m,k,j] = receiver_input   #0 -left sensor, 1 - right sensor
          receiver_interneuron_output[:,n,m,k,j] = AgentR.Outputs[0:InterSize]
          receiver_motor_output[:,n,m,k,j] = AgentR.Outputs[InterSize:InterSize+2]
      
      receiver_position = np.pi/4 # after the communication phase, put receiver at the center of the [0] region

      # courier phase
      for j,t in enumerate(time_courier):

          #angular sensors - sender removed
          receiver_input[0:2] = 0
          
          #bearing sensor
          receiver_slot_index = int((receiver_position - np.pi/2)//slot_size)
          if 0 <= receiver_position <= np.pi/2:
            for i in range(len(command)):
              receiver_input[i + 2] = 0
          else:
            for i in range(len(command)):
              receiver_input[i + 2] = environment[receiver_slot_index][i]
          #step
          AgentR.step(stepsize,receiver_input)
          receiver_position += stepsize*(AgentR.Outputs[InterSize+1] - AgentR.Outputs[InterSize])
          
          #close the circle
          if receiver_position > 2*np.pi:
            receiver_position -= 2*np.pi
          elif receiver_position < 0:
            receiver_position += 2*np.pi

          trajectory[0,n,m,k,j+300] = receiver_position
          trajectory[1,n,m,k,j+300] = sender_position
          receiver_sensor[:,n,m,k,j+300] = receiver_input   #0 -left sensor, 1 - right sensor
          receiver_interneuron_output[:,n,m,k,j+300] = AgentR.Outputs[0:InterSize]
          receiver_motor_output[:,n,m,k,j+300] = AgentR.Outputs[InterSize:InterSize+2]

          if t >= 40:
              if 0 <= receiver_position <= np.pi/2:
                point +=0
              else:
                if np.all(environment[receiver_slot_index] == command):
                  point += 1
                # print(command, environment[receiver_slot_index])
                else:
                  point += 0

            # print(environment[receiver_slot_index], command, point)
      
      point_trials[n,m,k] = point/200 # value from 0 to 1
      print(point_trials[n,m,k])
      # print(point_trials[n,m,k])

fitness = np.average(point_trials)
print('fitness', fitness)

#plot communication trajectory
E = environment_sample_size 
C = slots
R = 2
fig, tras = plt.subplots(E,C,figsize =(20,10))
for m in range(E):
  for n in range(C):
    for j in range(R):
      tras[m,n].plot(trajectory[1,m,j,n,0:300],'b') #sender trajectory
      tras[m,n].plot(trajectory[0,m,j,n,0:300],'--''r') #receiver trajectory
      tras[m,n].set_ylim([-0.5,6.5])
      tras[m,n].set_xlim([0,320])
      # tras[m,n].set_ylim([-0.5,6.5])
      #tras[m,n].plot(positionF[n])
plt.legend(['sender', 'receiver'])
plt.show()

print('fitness:', fitness)

# Plot courier trajectory
boundary_1 = np.ones(600)*np.pi/2
boundary_2 = np.ones(600)*((2*np.pi-np.pi/2)/slot_number+np.pi/2)
boundary_3 = np.ones(600)*2*np.pi
boundary_4 = np.zeros(600)
boundary_5 = np.ones(600)*((2*np.pi-np.pi/2)*2/slot_number+np.pi/2)
fig, tras = plt.subplots(E,C,figsize =(20,10))
for m in range(E):
  for n in range(C):
    for j in range(R):
      #tras[m,n].plot(trajectory[1,m,j,n,300:900]) #sender trajectory
      tras[m,n].plot(trajectory[0,m,j,n,300:900],'r') #receiver trajectory
      tras[m,n].plot(boundary_2,'-.''g')
      tras[m,n].plot(boundary_1,'-.''b')
      tras[m,n].plot(boundary_3,'-.''g')
      tras[m,n].plot(boundary_4,'-.''b')
      tras[m,n].plot(boundary_5,'-.''g')
      tras[m,n].set_ylim([-0.5,6.5])
      tras[m,n].set_xlim([0,620])
      # tras[m,n].set_ylim([-0.5,6.5])
      #tras[m,n].plot(positionF[n])
plt.legend(['receiver'])
plt.show()

#Plot neurons
n = 0 # Environment
m = 0 # Initial condition
k = 0 # Command
plt.figure(figsize=(10,15))
plt.subplot(511)
plt.plot(trajectory[0,n,m,k,:])
plt.plot(trajectory[1,n,m,k,0:300],'--')
# plt.plot(np.abs(trajectory[1,n,m,k,0:300]-trajectory[0,n,m,k,0:300]),'-.')
plt.legend(['receiver trajectory','sender trajectory','distance'])
plt.subplot(512)
plt.plot(receiver_sensor[0,n,m,k,:])
plt.plot(receiver_sensor[1,n,m,k,:])
plt.legend(['left sensor input','right sensor input'])
# plt.subplot(513)
# plt.plot(receiver_sensor_output[0,n,m,k,:])
# plt.plot(receiver_sensor_output[1,n,m,k,:])
# plt.legend(['left sensor output','right sensor output'])
plt.subplot(513)
plt.plot(receiver_sensor[2,n,m,k,:])
# plt.plot(receiver_sensor_output[2,n,m,k,:])
plt.legend(['label sensor input','label sensor output'])
plt.subplot(514)
plt.plot(receiver_interneuron_output[0,n,m,k,:])
plt.plot(receiver_interneuron_output[1,n,m,k,:])
plt.plot(receiver_interneuron_output[2,n,m,k,:])
plt.plot(receiver_interneuron_output[3,n,m,k,:])
plt.plot(receiver_interneuron_output[4,n,m,k,:])
plt.legend(['interneuron1','interneuron2','interneuron3','interneuron4','interneuron5'])
plt.subplot(515)
plt.plot(receiver_motor_output[0,n,m,k,:])
plt.plot(receiver_motor_output[1,n,m,k,:])
plt.legend(['left motor output','right motor output'])

#Plot sensor activation and neurons
plt.figure(figsize=(10,8))
plt.subplot(211)
plt.plot(receiver_sensor[0,0,0,0,0:300],'r')
plt.plot(receiver_sensor[1,0,0,0,0:300],'y')
plt.plot(receiver_sensor[0,0,0,1,0:300],'r,--')
plt.plot(receiver_sensor[1,0,0,1,0:300],'y,--')
# plt.legend(['s1','s2'],fontsize=24,loc='upper right')
plt.xticks([0,300],fontsize=22)
plt.yticks([0,1],fontsize=22)
plt.xlabel('time',fontsize=22)
plt.ylabel('sensor activation',fontsize=22)
plt.subplot(212)
plt.plot(receiver_interneuron_output[0,0,0,0,0:300],'b')
# plt.plot(receiver_interneuron_output[1,0,0,0,0:300],'g')
plt.plot(receiver_interneuron_output[2,0,0,0,0:300],'c')
# plt.plot(receiver_interneuron_output[3,0,0,0,0:300],'r')
# plt.plot(receiver_interneuron_output[4,0,0,0,0:300],'y')
plt.plot(receiver_interneuron_output[0,0,0,1,0:300],'b,--')
# plt.plot(receiver_interneuron_output[1,0,0,1,0:300],'g,--')
plt.plot(receiver_interneuron_output[2,0,0,1,0:300],'c,--')
# plt.plot(receiver_interneuron_output[3,0,0,1,0:300],'r,--')
# plt.plot(receiver_interneuron_output[4,0,0,1,0:300],'y,--')
plt.legend(['n1','n3'],fontsize=22)
plt.xticks([0,300],fontsize=22)
plt.yticks([0,1],fontsize=22)
plt.xlabel('time',fontsize=22)
plt.ylabel('interneuron activation',fontsize=22)
plt.subplots_adjust(hspace=0.3)

#Plot trajectory and neuron activation - 3 sector
, gridspec
from matplotlib.projections import Axes3D
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
from matplotlib import cm

x = np.linspace(0, 300, 300)
y = np.cos(trajectory[0,0,0,0,0:300])
z = np.sin(trajectory[0,0,0,0,0:300])

ys = np.cos(trajectory[1,0,0,0,0:300])
zs = np.sin(trajectory[1,0,0,0,0:300])

tp0 = [2,70]
yp0 = [y[tp0[0]],y[tp0[1]]]
zp0 = [z[tp0[0]],z[tp0[1]]]


x_2 = np.linspace(0, 300, 300)
y_2 = np.cos(trajectory[0,0,0,1,0:300])
z_2 = np.sin(trajectory[0,0,0,1,0:300])

ys_2 = np.cos(trajectory[1,0,0,1,0:300])
zs_2 = np.sin(trajectory[1,0,0,1,0:300])

size=40
tp = [2,130,205,270]
yp = [y_2[tp[0]],y_2[tp[1]],y_2[tp[2]],y_2[tp[3]]]
zp = [z_2[tp[0]],z_2[tp[1]],z_2[tp[2]],z_2[tp[3]]]


x_3 = np.linspace(0, 300, 300)
y_3 = np.cos(trajectory[0,0,0,2,0:300])
z_3 = np.sin(trajectory[0,0,0,2,0:300])

ys_3 = np.cos(trajectory[1,0,0,2,0:300])
zs_3 = np.sin(trajectory[1,0,0,2,0:300])

tp3 = [2,120,250]
yp3 = [y_3[tp3[0]],y_3[tp3[1]],y_3[tp3[2]]]
zp3 = [z_3[tp3[0]],z_3[tp3[1]],z_3[tp3[2]]]

fig = plt.figure(figsize = (12,18))

ax5 = fig.add_subplot(3,2,5,projection='3d')
ax2 = fig.add_subplot(3, 2, 3, projection='3d')
ax1 = fig.add_subplot(3, 2, 1, projection='3d')
ax3 = fig.add_subplot(3, 2, 2)
ax4 = fig.add_subplot(3, 2, 4)

ax6 = fig.add_subplot(3,2,6)


ax1.set_xticks([])
ax1.set_yticks([])
ax1.set_zticks([])

ax2.set_xticks([])
ax2.set_yticks([])
ax2.set_zticks([])

ax3.set_xticks([])
ax3.set_yticks([])

ax4.set_xticks([])
ax4.set_yticks([])

ax5.set_xticks([])
ax5.set_yticks([])

ax6.set_xticks([])
ax6.set_yticks([])


ax1.plot(x, y, z,'--')
ax1.plot(x, ys, zs)

ax1.set_xlabel('time',fontsize=22)
ax1.set_ylabel('position',fontsize=22)
ax1.set_xticks([0,300])
ax1.scatter(tp0,yp0,zp0,c='r',s=size)
ax1.tick_params(labelsize=22)
# lgd = ax1.legend(fontsize=20,bbox_to_anchor=(0.9,1))

ax2.plot(x, y_2, z_2,'--')
ax2.plot(x, ys_2, zs_2)
ax2.scatter(tp,yp,zp,c='r',s=size)
ax2.set_xlabel('time',fontsize=22)
ax2.set_ylabel('position',fontsize=22)
ax2.set_xticks([0,300])
ax2.tick_params(labelsize=22)
# lgd = ax1.legend(fontsize=20,bbox_to_anchor=(0.2,1))

ax3.plot(receiver_sensor[0,0,0,0,0:300],'r',label='sensor1')
ax3.plot(receiver_sensor[1,0,0,0,0:300],'y',label='sensor2')
ax3.set_xlabel('time',fontsize=22)
ax3.set_ylabel('activation',fontsize=22)
ax3.set_xticks([0,300])
ax3.tick_params(labelsize=22)
ax3.set_yticks([0,1])
ax3.tick_params(labelsize=22)
ax3.set_ylim(0,1.1)
#ax3.legend(['left sensor input','right sensor input'])

ax4.plot(receiver_sensor[0,0,0,1,0:300],'r')
ax4.plot(receiver_sensor[1,0,0,1,0:300],'y')
ax4.set_xlabel('time',fontsize=22)
ax4.set_xticks([0,300])
ax4.tick_params(labelsize=22)
ax4.set_ylabel('activation',fontsize=22)
ax4.set_ylim(0,1.1)
# ax4.set_ylabel('activation',fontsize=24)

ax5.plot(x, y_3, z_3,'--')
ax5.plot(x, ys_3, zs_3)
ax5.set_xlabel('time',fontsize=22)
ax5.set_ylabel('position',fontsize=22)
ax5.scatter(tp3,yp3,zp3,c='r',s=size)
ax5.set_xticks([0,300])
ax5.set_zticks([])
ax5.tick_params(labelsize=22)

ax6.plot(receiver_sensor[0,0,0,2,0:300],'r')
ax6.plot(receiver_sensor[1,0,0,2,0:300],'y')
ax6.set_xlabel('time',fontsize=22)
ax6.set_ylabel('activation',fontsize=22)
ax6.set_xticks([0,300])
ax6.tick_params(labelsize=22)
ax6.set_ylim(0,1.1)


leg = fig.legend(["receiver", "sender"], bbox_to_anchor=(0.5,0.83),fontsize = 22)
leg2 = fig.legend( bbox_to_anchor=(0.9,0.79),fontsize = 22)

fig.subplots_adjust(wspace=0.25, hspace=-0.2)
#ax1.set_position([0, 0, 0.5, 1])
#ax2.set_position([0.5, 0, 0.5, 1])
#ax3.set_position([0.05, 0, 0.4, 0.2])
#ax4.set_position([0.55, 0, 0.4, 0.2])

ax3.set_aspect(aspect=200)
ax4.set_aspect(aspect=200)
ax6.set_aspect(aspect=200)

plt.show()
# fig.savefig('samplefigure',bbox_extra_artists=(lgd,),bbox_inches='tight')
