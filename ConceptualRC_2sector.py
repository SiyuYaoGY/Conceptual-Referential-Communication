# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MYizLKnu9l3xVD6e4f-KD8Kti6w3DJZ_
"""
import matplotlib.pyplot as plt
import numpy as  np
import pathos
import agents_nosensoryneuron as agents
from stochsearch import MicrobialSearch
from stochsearch import EvolSearch
import itertools
from itertools import product, permutations

WeightRange = 15
TimeconstRange = 10
BiasRange = 10

def fitnessfunction(genotype, InterSize, slots, environment_sample_percent, random_seed):
  rng = np.random.default_rng(seed=random_seed)
# environment
  log_slots = int(np.ceil(np.log2(slot_number)))
  sensor_num = log_slots + 2
  sender_sensor_num = sensor_num
  receiver_sensor_num = sensor_num
  environment_sample_size = int(np.ceil(np.math.factorial(slots)*environment_sample_percent))
  #communication region: 0 ~ pi/2
  sender_initial_position = np.pi/4                #initial angular position of the sender
  receiver_initial_positions = np.pi/4 - np.array([-np.pi*3/32, np.pi*3/32]) # 2 initial positions of receiver
  num_receiver_initial_positions = np.shape(receiver_initial_positions)[0]
  slot_size = (3*np.pi/2)/slots

#time step
  #communication phase: 30s; 
  #courier phase: 60s, fitness function dependens on the time spent in the right area in the last 20s
  phase_communication = 30                               
  phase_courier = 60
  stepsize = 0.1                              # Size of the numerical integration step
  time_communication = np.arange(0.0,phase_communication,stepsize)     # Points in time
  time_courier = np.arange(0.0,phase_courier,stepsize)     # Points in time

#set up agents
  AgentS = agents.Agent(InterSize,sensor_num)
  AgentR = agents.Agent(InterSize,sensor_num)
  state0 = np.zeros(InterSize+2)         #initial state set to 0

#trials:
  sensor_values = [-1, 1]
  # below provides [(-1,), (1,)] when repeat=1
  all_slot_names = list(product(sensor_values, repeat=log_slots))
  # print(all_slot_names)
  slot_names = rng.choice(all_slot_names, size=slots, replace=False)
  # below provides [[[-1], [1]], [[1], [-1]]]
  all_environments = list(permutations(slot_names))
  sampled_environments = rng.choice(all_environments, size=environment_sample_size,replace=False)
  # print(sampled_environments) #[1][-1], [-1],[1]
  
  point_trials = np.zeros((environment_sample_size,num_receiver_initial_positions,slots))  #record the final point of each trial

  for n,environment in enumerate(sampled_environments):
    for m,receiver_position_set in enumerate(receiver_initial_positions):
      for k,command in enumerate(environment):
        
        #initialize agents
        AgentS.setWeights(np.reshape(WeightRange*(genotype[0:
                                                           sender_sensor_num*InterSize]*2-1),(sender_sensor_num,InterSize)),
                          np.reshape(WeightRange*(genotype[sender_sensor_num*InterSize:
                                                           sender_sensor_num*InterSize+InterSize**2]*2-1),
                                     (InterSize,InterSize)), 
                          np.reshape(WeightRange*(genotype[sender_sensor_num*InterSize+InterSize**2:
                                                           sender_sensor_num*InterSize+InterSize**2+InterSize*2]*2-1),
                                     (InterSize,2))) ## *WeightRange
        AgentR.setWeights(np.reshape(WeightRange*(genotype[sender_sensor_num*InterSize+InterSize**2+InterSize*2:
                                                           sender_sensor_num*InterSize+InterSize**2+InterSize*2+receiver_sensor_num*InterSize]*2-1),
                                     (receiver_sensor_num,InterSize)), 
                          np.reshape(WeightRange*(genotype[sender_sensor_num*InterSize+InterSize**2+InterSize*2+receiver_sensor_num*InterSize:
                                                           sender_sensor_num*InterSize+2*InterSize**2+InterSize*2+receiver_sensor_num*InterSize]*2-1),
                                     (InterSize,InterSize)), 
                          np.reshape(WeightRange*(genotype[sender_sensor_num*InterSize+2*InterSize**2+InterSize*2+receiver_sensor_num*InterSize:
                                                           sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize]*2-1),
                                     (InterSize,2)))
        AgentS.setBiases(BiasRange*(genotype[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize:
                                             sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize+2]*2-1))
        AgentR.setBiases(BiasRange*(genotype[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize+2:
                                             sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*2+4]*2-1))
        AgentS.setTimeConstants(genotype[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*2+4:
                                         sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*3+6]*TimeconstRange+1)
        AgentR.setTimeConstants(genotype[sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*3+6:
                                         sender_sensor_num*InterSize+2*InterSize**2+InterSize*4+receiver_sensor_num*InterSize+InterSize*4+8]*TimeconstRange+1)
        AgentS.initializeState(state0)
        AgentR.initializeState(state0)

        sender_input = np.zeros(sender_sensor_num)
        receiver_input = np.zeros(receiver_sensor_num)

        sender_position = sender_initial_position
        receiver_position = np.copy(receiver_position_set)

        point = 0   #the point receiver gets for evaluating fitness

        #communication phase
        for j,t in enumerate(time_communication):

            distance = sender_position - receiver_position
            #angular sensors
            if distance > np.pi/8 or distance < -np.pi/8:       
              sender_input[0:2] = 0
              receiver_input[0:2] = 0
            elif 0 < distance < np.pi/8:
              sender_input[0] = (np.pi/8 - distance)*8/np.pi
              sender_input[1] = 0
              receiver_input[0] = 0
              receiver_input[1] = (np.pi/8 - distance)*8/np.pi
            else:
              sender_input[1] = (np.pi/8 + distance)*8/np.pi
              sender_input[0] = 0
              receiver_input[1] = 0
              receiver_input[0] = (np.pi/8 + distance)*8/np.pi

            #bearing sensors
            for i in range(len(command)):
              sender_input[i + 2] = np.copy(command[i]) #(-1,1) for the right slot
              receiver_input[i + 2] = 0 #communication region
            
            AgentS.step(stepsize,sender_input)
            AgentR.step(stepsize,receiver_input)
            sender_position += stepsize*(AgentS.Outputs[InterSize+1] - AgentS.Outputs[InterSize])
            receiver_position += stepsize*(AgentR.Outputs[InterSize+1] - AgentR.Outputs[InterSize])

            #close the circle -- in this phase, the whole ring is used for communication
            if receiver_position > 2*np.pi:
              receiver_position -= 2*np.pi
            elif receiver_position < 0:
              receiver_position += 2*np.pi

            if sender_position > 2*np.pi:
              sender_position -= 2*np.pi
            elif sender_position < 0:
              sender_position += 2*np.pi
        
        receiver_position = np.pi/4 # after the communication phase, put receiver at the center of the [0] region
        # courier phase
        for j,t in enumerate(time_courier):

            #angular sensors - sender removed
            receiver_input[0:2] = 0
            
            #bearing sensor
            receiver_slot_index = int((receiver_position - np.pi/2)//slot_size)
            if 0 <= receiver_position <= np.pi/2:
              for i in range(len(command)):
                receiver_input[i + 2] = 0
            else:
              for i in range(len(command)):
                receiver_input[i + 2] = np.copy(environment[receiver_slot_index][i])
            #step
            AgentR.step(stepsize,receiver_input)
            receiver_position += stepsize*(AgentR.Outputs[InterSize+1] - AgentR.Outputs[InterSize])
            
            #close the circle
            if receiver_position > 2*np.pi:
              receiver_position -= 2*np.pi
            elif receiver_position < 0:
              receiver_position += 2*np.pi

            if t >= 40:
              if 0 <= receiver_position <= np.pi/2:
                point +=0
              else:
                if environment[receiver_slot_index] == command:
                  point += 1
                # print(command, environment[receiver_slot_index])
                else:
                  point += 0

              # print(environment[receiver_slot_index], command, point)
        
        point_trials[n,m,k] = point/200 # value from 0 to 1
        # print(point_trials[n,m,k])
        # print(point_trials[n,m,k])
  
  fitness = np.average(point_trials)
  # print('fitness', fitness)
  return fitness

from functools import partial
# es = EvolSearch(evol_params)
InterSize = 5
slot_number = 2
sensor_num = int(np.log2(slot_number)) + 2
environment_sample_percent = 1
random_seed =0

#multi-processing evolsearch, from https://github.com/madvn/stochsearch/tree/master/stochsearch
#set up parameters
evol_params = {
    'num_processes' : 80, # (optional) number of processes for multiprocessing.Pool
    'pop_size' : 400,    # population size
    'genotype_size': 2*sensor_num*InterSize +2*InterSize**2+InterSize*4+2*(sensor_num*2+2*InterSize+4), # dimensionality of solution
    'fitness_function': partial(fitnessfunction,InterSize=InterSize,
                                slots=slot_number,environment_sample_percent=environment_sample_percent,
                                random_seed=random_seed), # custom function defined to evaluate fitness of a solution
    'elitist_fraction': 0.05, # probability of winner genes transfecting loser
    'mutation_variance': 0.05, # mutation noise added to offspring.
}
es = EvolSearch(evol_params)
# #Start search
# num_gens = 100
# es.execute_search(num_gens)

best_fit = []
mean_fit = []
num_gen = 0
max_num_gens = 1500
desired_fitness = 0.98
#while es.get_best_individual_fitness() < desired_fitness and num_gen < max_num_gens:
while num_gen < max_num_gens:
    print('Gen #'+str(num_gen)+' Best Fitness = '+str(es.get_best_individual_fitness()))
    es.step_generation()
    best_fit.append(es.get_best_individual_fitness())
    mean_fit.append(es.get_mean_fitness())
    num_gen += 1
    #save every 10 generations
    if (num_gen % 10 == 9):
      np.save('2s_Conceptual1_best_fit.npy',best_fit)
      np.save('2s_Conceptual1_mean_fit.npy',mean_fit)
      np.save('2s_Conceptual1_individual_genotype.npy',es.get_best_individual())
      np.save('2s_Conceptual1_individual_fitness.npy',es.get_best_individual_fitness())


